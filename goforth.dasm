;
; Copyright (c) 2012, Matt Hellige
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without 
; modification, are permitted provided that the following conditions are met:
;
;   Redistributions of source code must retain the above copyright notice, 
;   this list of conditions and the following disclaimer.
;
;   Redistributions in binary form must reproduce the above copyright 
;   notice, this list of conditions and the following disclaimer in the 
;   documentation and/or other materials provided with the distribution.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
; "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
; LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
; A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
; HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
; SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
; LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

; this is an implementation of forth for the dcpu-16 augmented with a few
; io instructions.
;
; the core dictionary layout and assembler routines are influenced by
; jonesforth:
;   http://rwmj.wordpress.com/2010/08/07/jonesforth-git-repository/
; although jonesforth has a number of quirks (and so does this one) and
; things diverge pretty quickly.
;
; in any case, this is a 'classic' indirect-threaded forth, in which
; code fields contain pointers to executable machine code. i've given
; some thought to direct threading, but given the rather bizarre cost
; model of the dcpu-16, it doesn't seem to me that it would actually
; be significantly faster, and it would definitely be more complex
; (since, for example, code words might have to be larger than 1 cell).
; the specific dcpu-16 characteristics that matter here are:
;    - memory access is literally free (a single cycle)...
;    - ... EXCEPT when you're decoding the instruction stream, in which
;      case there's a penalty of 1 cycle per word
;    - addition is free (0 extra cycles) when it's used to compute an address
;      offset for an operand, otherwise it's 2 extra cycles
; direct threading might be more of a win if the forth ip points to the
; currently executing word rather than to the *next* word, but that would
; be a more significant change, and i'd have to think harder about the
; ramifications. maybe some other time...
;
; register mappings:
;  SP  return stack pointer (rsp sometimes below)
;  Z   data stack pointer
;  Y   forth instruction pointer (ip)
;  X   forth codeword pointer
;
; notice we use the 'hardware' stack for the return stack and explicitly
; manage the data stack. we also do not keep the top of the data stack
; in a register. both of these decisions may be worth revisiting.
;
; dictionary entries:
;     +----------------------+
;     | 16 link to prev word |
;     | 16 flags/name length |
;     | 16 ... name
;     | 16 codeword          |
;     | 16 ... definition    |
;     +----------------------+
; in the case of primitives, codeword simply points to definition, which is
; machine code. (it could be anywhere, but will generally follow immediately
; after codeword.) in the case of forth words, we have:
;     +----------------------+
;     | 16 link to prev word |
;     | 16 flags/name length |          DOCOL
;     | 16 ... name          |         +---------------------+
;     | 16 ptr to DOCOL     ---------->| 16 ... machine code |
;     | 16 ... ptr to words  |         | 16 ... NEXT         |
;     | 16 ptr to EXIT       |         +---------------------+
;     +----------------------+
; 'ptr to ...' means a pointer directly to the codeword field of the definition.

; the overall memory layout. this isn't yet fully implemented, but an
; important point is that we want to be sure that everything important
; is below h, so that we can simply dump a bootable image by including
; only everything from 0 to h. we have to be just a bit careful about
; variables, but it's pretty easy to get it right.
;     +----------------------+
;     | block buffers (2kb)  |<--- r0
;     | return stack         |
;     |        |             |
;     |        v             |
;     | text input buffer    |<--- tib,s0 0xf000
;     | data stack           |
;     |        |             |
;     |        v             |
;     | reserved (kbd buf)   | 0x9000 - 0x900f
;     | unused (?)           |
;     | reserved (video)     | 0x8000 - 0x8280
;     |        ^             |
;     |        |             |
;     | pad (n words from h) |<--- pad
;     |        ^             |
;     |        |             |<--- h
;     | user dictionary      |
;     | system variables     |
;     | core image           |
;     +----------------------+

; finally, m4 is a pretty broke-ass way to get macros, but i want to invest as
; little as possible in the dcpu assembler. i'd rather bootstrap everything from
; within forth as soon as possible...

; TODO all the io primitives and the dictionary use whole words for ascii chars.
; this is much easier in the absence of byte addressing, but it's also terribly
; wasteful. fix, or at least introduce 'packed strings' for dictionary names.

define(s0_, 0xf000)
define(r0_, 0x0000)
define(keybuf_, 0x9000)
define(keybufsiz_, 0x10)
define(vidram_, 0x8000)
define(vidramsiz_, 0x0180)

define(next,
           `set x, [y]
            add y, 1
            set pc, [x]')

define(pushrsp,
           `set push, $1')

define(poprsp,
           `set $1, pop')

define(link, 0)

define(f_immed, 0x80)
define(f_hidden, 0x20)
define(f_lenmask, 0x1f)

; defheader(forthnam, flags, asmname)
; all the words use this macro for their header. they're all the same
; up to the code field
define(defheader, `
name_$3:    dw link
            define(`link', name_$3)
            dw eval($2 | len($1))
            dzw "$1"
$3:         ')

; defword(forthname, flags, asmname)
define(defword, `
            defheader($1, $2, $3)
            dw docol')
            ; word ptrs follow...

; defcode(forthname, flags, asmname)
define(defcode, `
            defheader($1, $2, $3)
            dw code_$3
code_$3:')  ; code follows...

; defvar(forthname, asmname, value)
define(defvar, `
            defheader($1, 0, $2)
            dw dovar
var_$2:     dw $3
')

; defconst(forthname, asmname, value)
define(defconst, `
            defheader($1, 0, $2)
            dw docon
            dw $3
')

; boot...
            ; return stack grows down from 0xffff
            ; but sp already starts at 0, so we might as well assume it
            set z, s0_              ; data stack grows down from here
            set [curkey], 0         ; reset keyboard buffer position (see below)
            set [curvid], 0         ; reset video ram position
            set [curline], 0        ; reset current line start position
            set y, var_bootword     ; boot up
            next

            ; we need a few variables for positions in the various memory
            ; mapped buffers, but we need to be very sure that they get reset
            ; to 0 on every boot. we could just stick them somewhere higher in
            ; the address range (i.e., outside of the saved image), but just
            ; explicitly setting them is probably safer and clearer.
curkey:     dw 0                    ; position in keyboard buffer
curvid:     dw 0                    ; position in video ram
curline:    dw 0                    ; start of current line (for backspace)


; interpreter for variables (and newly created words, per ans)
dovar:      sub z, 1                ; push data field address
            set [z], x              ; which is one cell after the code field
            add [z], 1
            next

; interpreter for constants
docon:      sub z, 1                ; push data field contents
            add x, 1                ; data field is one cell after the code field
            set [z], [x]
            next

; interpreter for forth words
docol:      pushrsp(y)
            set y, x                ; set ip to word definition...
            add y, 1                ; which is one cell after the code field
            next

; interpreter for does> words. this is some funky business... the obvious way
; to implement does> is just to compile the address of dodoes in the code field
; (i.e., in place of docol) and have it look up the address of the does-handler
; in the cell following x. but since it's nice if does> works on any kind of
; word, then the obvious solution is to change docol to 'add y, 2' and waste a
; cell of storage in every word. on a resource-constrained machine, this is a
; major bummer. so, instead, for each instance of does>, we create a dispatch
; jsr instruction at the start of the does-handler, just prior to the start of
; the compiled forth words. does> then places the address of this jsr in the
; code field of the child word, and dodoes gets its does-handler address on the
; regular 'hardware' stack. and at this point, it's probably easier just to see
; it...
;     +----------------------+
;     | 16 link to prev word |
;     | 16 flags/name length |          DODOES
;     | 16 ... name          |         +------------------------+
;  +--- 16 ptr to dispatch   |  +----->| 16 ... machine code    |
;  |  | 16 ... ptr to words  |  |      |   (does> code in peek) |
;  |  | 16 ptr to EXIT       |  |      | 16 ... NEXT            |
;  +->| 16/32  jsr DODOES   ----+      +------------------------+
;     | 16 ... ptr to words  |
;     | 16 ptr to EXIT       |
;     +----------------------+
; note: this whole trick is much simpler since everything is just 16-bit cells.
; we don't have to worry much about alignment, funky instruction sizes, etc.,
; and there's no memory protection, so we can jit the does dispatch wherever
; we want.
dodoes:     set a, pop              ; stash the word following the jsr dispatch
            pushrsp(y)              ; now that 'a' is safe, push y
            sub z, 1                ; push the data field of the child word
            set [z], x
            add [z], 1
            set y, a                ; and now begin executing the does> body
            next

            ; and here's the funky little piece of code that compiles the
            ; actual dispatch instruction for the does-handler.
            defcode(create-does, 0, createdoes)
            set i, dhcode_          ; start of does-handler dispatch
cdoes.1:    set j, [i]              ; setup...
            jsr comma_              ; compile the word in j
            add i, 1
            ifg dhend_, i           ; until the end of the dispatch
            set pc, cdoes.1
            next
dhcode_:    jsr dodoes
dhend_:     ; just in case the jsr is 2 words...

; built-in constants and variables...
; 'latest' and 'h' are defined at the very end, so they can be properly
; initialized...
            defconst(tib, tib, s0_)
            defvar(>in, inptr, 0)
            defvar(srcptr, srcptr, 0)
            defvar(srclen, srclen, 0)
            defvar(state, state, 0)
            defvar(r0, r0, r0_)
            defvar(s0, s0, s0_)
            defvar(base, base, 10)
            defvar(conattr, conattr, 0)
; we also reflect the addresses of the xt values for 'see', custom compiling
; words, etc...
            defconst(docol:, docolf, docol)
            defconst(dovar:, dovarf, dovar)
            defconst(docon:, doconf, docon)
            defconst(dodoes:, dodoesf, dodoes)
            defconst(lenmask, lenmaskf, f_lenmask)


; now we start right in with a bunch of primitive words...

; stack manipulation:
            defcode(drop, 0, drop)
            add z, 1
            next

            defcode(swap, 0, swap)
            set a, [z]
            set [z], [1+z]
            set [1+z], a
            next

            defcode(dup, 0, dup)
            sub z, 1
            set [z], [1+z]
            next

            defcode(over, 0, over)
            sub z, 1
            set [z], [2+z]
            next

            defcode(rot, 0, rot)
            set a, [z]
            set [z], [2+z]
            set [2+z], [1+z]
            set [1+z], a
            next

            defcode(-rot, 0, nrot)
            set a, [z]
            set [z], [1+z]
            set [1+z], [2+z]
            set [2+z], a
            next

            defcode(2drop, 0, twodrop)
            add z, 2
            next

            defcode(2dup, 0, twodup)
            sub z, 2
            set [1+z], [3+z]
            set [z], [2+z]
            next

            defcode(2swap, 0, twoswap)
            set a, [z]
            set b, [1+z]
            set [z], [2+z]
            set [1+z], [3+z]
            set [2+z], a
            set [3+z], b
            next

            defcode(?dup, 0, qdup)
            ife [z], 0
            add pc, 2
            sub z, 1
            set [z], [1+z]
            next

; basic arithmetic
            defcode(+, 0, plus)
            add [1+z], [z]
            add z, 1
            next

            defcode(-, 0, minus)
            sub [1+z], [z]
            add z, 1
            next

            defcode(1+, 0, oneplus)
            add [z], 1
            next

            defcode(1-, 0, oneminus)
            sub [z], 1
            next

            defcode(*, 0, times)
            set a, [z]
            add z, 1
            mul [z], a
            next

            defcode(u/, 0, udiv)
            set a, [z]
            add z, 1
            div [z], a
            next

            defcode(u/mod, 0, udivmod)
            set a, [z]
            set [z], [1+z]
            mod [1+z], a
            div [z], a
            next

            ; signed division is symmetric (truncating). ans allows
            ; either, it's a holy war and i have no horse in the race.
            ; but i suspect that if notch implements divi, it will be
            ; truncating, so this will then be a single instruction.
            defcode(/, 0, div)
            set a, [z]              ; a is divisor
            add z, 1
            set b, [z]              ; b is dividend
            set c, b
            xor c, a
            shr c, 15               ; c is 1 if signs differ
            ifg 0x8000, a           ; a is positive
            set pc, div.1
            xor a, 0xffff           ; else make it positive
            add a, 1
div.1:      ifg 0x8000, b           ; likewise, b is positive
            set pc, div.2
            xor b, 0xffff           ; else make it positive
            add b, 1
div.2:      div b, a                ; unsigned quotient is in b
            ife c, 0                ; were the signs the same?
            set pc, div.3           ; if so, done
            xor b, 0xffff           ; else negate the quotient
            add b, 1
div.3:      set [z], b              ; and return it
            next

            defcode(lshift, 0, lshift)
            set a, [z]
            add z, 1
            shl [z], a
            next

            defcode(rshift, 0, rshift)
            set a, [z]
            add z, 1
            shr [z], a
            next

            defcode(2*, 0, twomul)
            shl [z], 1
            next

            defcode(and, 0, bitand)
            and [1+z], [z]
            add z, 1
            next

            defcode(or, 0, bitor)
            bor [1+z], [z]
            add z, 1
            next

            defcode(xor, 0, bitxor)
            xor [1+z], [z]
            add z, 1
            next

            defcode(invert, 0, bitnot)
            xor [z], 0xffff
            next

            defcode(negate, 0, negate)
            xor [z], 0xffff         ; negate
            add [z], 1
            next

            ; TODO more...

; comparisons
            defcode(=, 0, equal)
            set a, 0
            ife [z], [1+z]
            set a, 0xffff
            add z, 1
            set [z], a
            next

            defcode(<>, 0, nequal)
            set a, 0
            ifn [z], [1+z]
            set a, 0xffff
            add z, 1
            set [z], a
            next

            defcode(<, 0, less)
            set a, 0
            add [z], 0x8000
            add [1+z], 0x8000
            ifg [z], [1+z]
            set a, 0xffff
            add z, 1
            set [z], a
            next

            defcode(>, 0, gt)
            set a, 0
            add [z], 0x8000
            add [1+z], 0x8000
            ifg [1+z], [z]
            set a, 0xffff
            add z, 1
            set [z], a
            next

            defcode(u<, 0, uless)
            set a, 0
            ifg [z], [1+z]
            set a, 0xffff
            add z, 1
            set [z], a
            next

            defcode(u>, 0, ugt)
            set a, 0
            ifg [1+z], [z]
            set a, 0xffff
            add z, 1
            set [z], a
            next

            defcode(u<=, 0, ulteq)
            set a, 0
            ifg [z], [1+z]
            set a, 0xffff
            ife [z], [1+z]
            set a, 0xffff
            add z, 1
            set [z], a
            next

            defcode(u>=, 0, ugteq)
            set a, 0
            ifg [1+z], [z]
            set a, 0xffff
            ife [1+z], [z]
            set a, 0xffff
            add z, 1
            set [z], a
            next

            defcode(0=, 0, zequ)
            ife [z], 0
            set pc, zequ.1
            set [z], 0
            next
zequ.1:     set [z], 0xffff
            next

            ; TODO more...

; internals, execution
            defcode(exit, 0, exit)
            poprsp(y)
            next

            defcode(lit, 0, lit)
            ; push the value at the forth ip and advance it
            sub z, 1
            set [z], [y]
            add y, 1
            next

            defcode(litstring, 0, litstring)
            ; push the count and following string from the forth ip
            sub z, 2
            set [z], [y]
            set [1+z], y
            add [1+z], 1
            add y, [y]
            add y, 1
            next

            defcode(execute, 0, execute)
            set x, [z]              ; get xt from stack
            add z, 1                ; and pop it
            set pc, [x]             ; execute
            ; nb: no `next'!

; memory
            defcode(!, 0, store)
            set a, [z]              ; fetch destination address
            set [a], [1+z]          ; store the `next' stack value to dest
            add z, 2                ; pop both values
            next

            defcode(@, 0, fetch)
            set a, [z]              ; fetch source address
            set [z], [a]            ; read, replace top of stack
            next

            defcode(+!, 0, addstore)
            set a, [z]              ; fetch destination address
            add [a], [1+z]          ; add `next' value to dest
            add z, 2                ; pop both values
            next

            defcode(-!, 0, substore)
            set a, [z]              ; fetch destination address
            sub [a], [1+z]          ; subtract `next' value from dest
            add z, 2                ; pop both values
            next

            ; ( src dest u -- )
            defcode(move, 0, move)
            set a, [2+z]            ; src in a
            set b, [1+z]            ; dest in b
            set c, b                ; limit in c
            add c, [z]
            add z, 3                ; pop args
move.2:     ife b, c                ; done?
            set pc, move.1
            set [b], [a]            ; assign
            add a, 1                ; increment
            add b, 1
            set pc, move.2          ; again...
move.1:     next

; direct stack access
            defcode(>r, 0, tor)
            pushrsp([z])
            add z, 1
            next

            defcode(r>, 0, fromr)
            sub z, 1
            poprsp([z])
            next

            defcode(r@, 0, rpeek)
            sub z, 1
            set [z], peek
            next

            defcode(rdrop, 0, rdrop)
            poprsp(a)               ; destination is irrelevant
            next

            defcode(2>r, 0, twotor)
            pushrsp([1+z])
            pushrsp([z])
            add z, 2
            next

            defcode(2r>, 0, twofromr)
            sub z, 2
            poprsp([z])
            poprsp([1+z])
            next

            defcode(2r@, 0, tworpeek)
            ; double ugly because dcpu-16 doesn't support sp+lit addressing
            sub z, 2
            set a, sp
            set [z], [a]
            set [1+z], [1+a]
            next

            defcode(2rdrop, 0, twordrop)
            poprsp(a)               ; destination is irrelevant
            poprsp(a)               ; destination is irrelevant
            next

            defcode(rsp!, 0, rspstore)
            set sp, [z]
            add z, 1
            next

            defcode(rsp@, 0, rspfetch)
            sub z, 1
            set [z], sp
            next

            defcode(dsp!, 0, dspstore)
            set z, [z]
            next

            defcode(dsp@, 0, dspfetch)
            set a, z
            sub z, 1
            set [z], a
            next

            defcode(branch, 0, branch)
            add y, [y]
            next

            defcode(0branch, 0, zbranch)
            ife [z], 0              ; check condition
            set pc, zbranch.1
            add z, 1                ; pop
            add y, 1                ; skip offset
            next
zbranch.1:  add z, 1                ; pop
            add y, [y]              ; take the branch
            next

; i/o
            defcode(dump-core, 0, dumpcore)
            img [z]                 ; dump. expects limit address on stack
            add z, 1                ; pop arg
            next

            defcode(bye, 0, bye)
            die 0                   ; make vm exit.

            defcode(debug, 0, debug)
            dbg 0                   ; enter emulator debugger
            next


            ; awaits a keypress. uses i and returns key in j
readkey:    set i, [curkey]
            add i, keybuf_
            ife [i], 0              ; no key yet...
            set pc, readkey
            set j, [i]              ; read it
            set [i], 0              ; erase it for `next' time
            add [curkey], 1         ; advance
            mod [curkey], keybufsiz_
            set pc, pop

            defcode(key, 0, key)
            sub z, 1
            jsr readkey             ; fetch keypress
            jsr emit_               ; echo j to the terminal
            set [z], j
            next

            defcode(emit, 0, emit)
            set j, [z]              ; prep the call
            add z, 1                ; and pop it
            jsr emit_               ; write the char
            next

            ; writes the word in j to vidram. handles scrolling, newline,
            ; and backspace. uses register i.
emit_:      ifn j, 0x0a             ; check nl
            set pc, emit_.1
            set i, [curvid]         ; erase cursor
            add i, vidram_
            set [i], 0
            add [curvid], 31        ; `next' line. nb, this only works if line
            and [curvid], -32       ; width is a power of 2
            set [curline], [curvid] ; set start of current line (for backspace)
            set pc, emit_.3
emit_.1:    ifn j, 0x08             ; check bs
            set pc, emit_.2
            ife [curline], [curvid] ; at line start. bail.
            set pc, emit_.3
            ife [curline], 0        ; at start of vidram. vanishingly unlikely,
            set pc, emit_.3         ;    but just in case... bail.
            sub [curvid], 1         ; do the backspace
            set i, [curvid]         ; prep rubout
            add i, vidram_
            set [i], 0              ; rubout the char
            set [1+i], 0            ; rubout the cursor
            set pc, emit_.3
emit_.2:    set i, [curvid]         ; load `next' vidram slot
            add i, vidram_
            set [i], [var_conattr]  ; set terminal attributes
            shl [i], 7
            bor [i], j              ; write the char
            add [curvid], 1         ; advance
emit_.3:    ife [curvid], vidramsiz_ ; we'll always hit the number exactly...
            jsr scroll_
            set i, [curvid]
            add i, vidram_
            set [i], [var_conattr]  ; set terminal attributes
            bor [i], 1              ; the cursor always blinks
            shl [i], 7
            bor [i], 0x5f           ; show cursor
            set pc, pop

            ; scroll the screen. uses i and j.
scroll_:    set j, vidram_          ; limit in j
            add j, vidramsiz_
            sub j, 32
            set i, vidram_          ; start scrolling from line 1
scroll_.1:  set [i], [32+i]
            add i, 1
            ifg j, i
            set pc, scroll_.1
            add j, 32               ; blank last line
scroll_.2:  set [i], 0
            add i, 1
            ifg j, i
            set pc, scroll_.2
            sub [curvid], 32
            sub [curline], 32
            set pc, pop

            defcode(cr, 0, cr)
            set j, 0x0a
            jsr emit_
            next

            ; ( a u1 -- u2 )
            defcode(accept, 0, accept)
            set a, [1+z]            ; dest addr in a
            add [z], a              ; limit addr in [z]
accept.1:   ife a, [z]              ; bail if at limit
            set pc, accept.2
accept.3:   jsr readkey             ; fetch keypress
            set [a], j
            ifn [a], 0x08           ; skip if not backspace/delete
            set pc, accept.4
            jsr emit_               ; erase from the terminal
            ifg a, [1+z]            ; backspace input buffer, if possible
            sub a, 1
            set pc, accept.3        ; ...and try again
accept.4:   ife [a], 0x0a           ; bail if newline
            set pc, accept.2
            jsr emit_               ; echo it to the terminal, key is still in j
            add a, 1
            set pc, accept.1
accept.2:   set j, 0x20             ; echo a space
            jsr emit_
            add z, 1                ; pop 1 arg
            sub a, [z]              ; compute length
            set [z], a              ; push it
            next

            ; TODO handle non-printing chars
            ; ( a u -- )
            defcode(type, 0, type)
            set a, [1+z]            ; src addr in a
            add [z], a              ; limit addr in [z]
type.1:     ife a, [z]              ; bail if at limit
            set pc, type.2
            set j, [a]              ; write char
            jsr emit_
            add a, 1
            set pc, type.1
type.2:     add z, 2                ; pop args
            next

            ; ( -- ? )
            defword(refill, 0, refill)
            dw tib
            dw dup, srcptr, store   ; set srcptr to tib
            dw lit, 256, accept     ; read line into tib
            dw srclen, store        ; set srclen to result
            dw lit, 0, inptr, store ; set >in to 0
            dw lit, 0xffff          ; push true
            dw exit

            ; ( -- a len )
            defword(source, 0, source)
            dw srcptr, fetch        ; push ptr and len
            dw srclen, fetch
            dw exit


; parsing, compiling

            ; expects address of string in a, returns bool in j
isspace_:   set j, 0
            ife [a], 0x20           ; space
            set j, -1
            ife [a], 0x09           ; tab
            set j, -1
            ife [a], 0x0d           ; cr
            set j, -1
            ife [a], 0x0a           ; lf
            set j, -1
            set pc, pop

            ; Takes address of character in b and lowers it in-place.
lower_:     ifg [b], 0x5a
            set pc, lower_.end
            ifg 0x41, [b]
            set pc, lower_.end
            add [b], 0x20 ; Shift the character from upper- to lowercase.
lower_.end: set pc, pop

            ; expects address of string in a, upper limit in c
dropspace_: ife a, c
            set pc, pop             ; input exhausted, bail
            jsr isspace_            ; space? result in j
            ife j, 0                ; not a space, return
            set pc, pop
            add a, 1                ; `next' char
            set pc, dropspace_

            ; ( char "ccc<char>" -- a u )
            defcode(parse, 0, parse)
            set i, [z]              ; load terminator
            sub z, 1                ; we'll have one more result than arg
            set a, [var_srcptr]     ; load srcptr
            set c, a
            add c, [var_srclen]     ; store limit in c
            add a, [var_inptr]      ; add >in, a is current parse location
            jsr dropspace_          ; ignore initial whitespace
parse.2:    set [1+z], a            ; push start of word
parse.3:    ife a, c
            set pc, parse.end       ; input exhausted, bail
            ife [a], i              ; check for terminator
            set pc, parse.end2      ; if found, done!
            add a, 1
            set pc, parse.3
            ; TODO this is some ugly duplication, but it's late and i don't
            ; care enough to fix it right now. the only difference between
            ; the `next' two snippets is the "add a, 1" in the middle.
parse.end2: set [z], a              ; push parsed length
            sub [z], [1+z]
            add a, 1                ; include terminator
            set [var_inptr], a      ; store `next' location back to >in
            sub [var_inptr], [var_srcptr]
            next
parse.end:  set [z], a              ; push parsed length
            sub [z], [1+z]
            set [var_inptr], a      ; store `next' location back to >in
            sub [var_inptr], [var_srcptr]
            next

            ; ( "<spaces>name" -- a u )
            defcode(parse-word, 0, parseword)
            sub z, 2                ; we'll have two results
            set a, [var_srcptr]     ; load srcptr
            set c, a
            add c, [var_srclen]     ; store limit in c
            add a, [var_inptr]      ; add >in, a is current parse location
            jsr dropspace_          ; ignore initial whitespace
pword.2:    set [1+z], a            ; push start of word
pword.3:    ife a, c
            set pc, pword.end       ; input exhausted, bail
            jsr isspace_            ; space? result in j
            ifn j, 0
            set pc, pword.end       ; space, all done!
            add a, 1
            set pc, pword.3
pword.end:  set [z], a              ; push parsed length
            sub [z], [1+z]
            set [var_inptr], a      ; store `next' location back to >in
            sub [var_inptr], [var_srcptr]
            next


            ; >number ( u1 a1 u1 -- u2 a2 u2 ) TODO wrap!

            ; TODO other bases!
            ; convert word to number. word len in a, ptr in b, accumulator in i.
            ; modifies i, advances b and decrements a as it parses...
tonum_:     ife a, 0                ; bail if exhausted
            set pc, tonum_.end
            ifg [b], 0x39           ; Try a character if char > '9'
            set pc, tonum_.chr
            ifg 0x30, [b]           ; bail if char < '0'
            set pc, tonum_.end
            set j, [b]
            sub j, 0x30             ; remove '0'
tonum_.mul: mul i, [var_base]       ; shift i one place
            add i, j                ; add it
            sub a, 1                ; advance to `next' char
            add b, 1
            set pc, tonum_          ; and begin again...
tonum_.chr: jsr lower_              ; Lower the character.
            ifg [b], 0x7a           ; Not a lowercase character.
            set pc, tonum_
            ifg 0x61, [b]           ; Also not a lowercase character.
            set pc, tonum_
            set j, [b]
            sub j, 0x57
            set pc, tonum_.mul
tonum_.end: set pc, pop

            ; convert word to number, possibly negative.
            ; takes word len in a, ptr in b.
            ; returns result in i, advances b and decrements a as it parses...
number_:    set i, 0                ; no accumulator so far
            set push, 0             ; number is positive
            ife a, 0                ; bail if exhausted
            set pc, numb_.end
            ifn [b], 0x2d           ; if first char is '-'
            set pc, numb_.pos
            set peek, 1             ; number is negative
            sub a, 1                ; skip '-'
            add b, 1
numb_.pos:  jsr tonum_
numb_.end:  ife pop, 0              ; if positive, we're done
            set pc, pop
            xor i, 0xffff           ; else negate
            add i, 1
            set pc, pop

            defword(allot, 0, allot)
            dw h, addstore          ; increment h
            dw exit

            defword(create, 0, create)
            dw here                 ; save current h
            dw latest, fetch, comma ; compile link ptr
            dw latest, store        ; update latest
            dw parseword            ; parse a word TODO check for empty!
            dw dup, comma           ; compile name length
            dw here, swap           ; set up to copy, stack ( src dest n -- )
            dw dup, allot           ; advance h first
            dw move                 ; copy name
            dw lit, dovar, comma    ; compile the cfa
            dw exit

            ; ( addr -- )  toggles hidden given dict entry
            defcode(hidden, 0, hidden)
            set a, [z]
            add a, 1                ; find flags/len
            xor [a], f_hidden       ; toggle
            add z, 1                ; pop
            next

            defcode(immediate, f_immed, immediate)
            set a, [var_latest]     ; get latest
            add a, 1                ; find flags/len
            xor [a], f_immed        ; toggle
            next

            defword(here, 0, here)
            dw h, fetch
            dw exit

            ; we've reached the limits of masm's hokey parsing...
            ; this is just `defcode' expanded and without dzw:
            ;`defcode'(`,', 0, comma)
name_comma: dw link
            define(`link', name_comma)
            dw 1                    ; no flags, length 1
            dw 0x2c                 ; comma
comma:      dw code_comma
code_comma: ; code follows...
            set j, [z]              ; set up the call
            jsr comma_
            add z, 1                ; pop stack
            next

            ; factored out so we can also call it natively.
            ; expects word to compile in j
comma_:     set b, [var_h]          ; fetch `next' dest
            set [b], j              ; write the value
            add [var_h], 1          ; increment h
            set pc, pop

            defcode([, f_immed, lbrac)
            set [var_state], 0      ; done compiling
            next

            defword(], 0, rbrac)
            dw lit, 1, state, store ; begin compiling
            dw parseword
            dw dup, zbranch, 12     ; done?
            dw compile_             ; call the primitive
            dw succ, fetch
            dw zbranch, 9           ; error, nothing to drop, just bail
            dw state, fetch         ; must retest state flag, an immediate word
            dw zbranch, 4           ;   can change it...
            dw branch, -14
            dw twodrop
            dw exit
            ; TODO error handling! really we should abort here or whatever...
            dw lit, 0x65, emit      ; but for now, we can at least spew an 'e'
            dw exit

            ; this can't return anything, since execution will cause us to
            ; eventually `next' our way back into forth code. we could make
            ; it work by fiddling around with the forth ip, but it doesn't seem
            ; worth it... we use a var to communicate errors...
            ; ( a u -- )
compile_:   dw compile__
compile__:  set a, [z]              ; load length
            set b, [1+z]            ; load ptr
            add z, 2
            set [var_succ], 0xffff
            jsr find_               ; dictionary search, results in i, j
            ife i, 0
            set pc, compile_.1      ; not in dict...
            ife i, 1
            set pc, compile_.4      ; not an immediate word.
            set x, j                ; immediate word. update the codeword pointer
            set pc, [x]             ; and execute it...
compile_.4: jsr comma_              ; non-immediate. compile the value in j.
            set pc, compile_.3
compile_.1: jsr number_
            ife a, 0
            set pc, compile_.2
            set [var_succ], 0x0     ; not a number. bail.
            set pc, compile_.3
compile_.2: set j, lit
            jsr comma_              ; compile ptr to 'lit'
            set j, i
            jsr comma_              ; compile the numeric value in j
compile_.3: next

            defword(:, 0, colon)
            dw create               ; make the dict entry
            dw latest, fetch        ; grab the addr of created word
            dw dup, hidden          ; hide it
            dw tocfa, lit, docol    ; set the codeword
            dw swap, store
            dw rbrac                ; compile
            dw exit

            defword(;, f_immed, semi)
            dw lit, exit, comma     ; append exit
            dw latest, fetch, hidden; unhide it
            dw lbrac                ; stop compiling
            dw exit

            defword(variable, 0 , variable)
            dw create               ; make the dict entry
            dw lit, 1, allot        ; reserve the space
            dw exit

            defword(constant, 0 , constant)
            dw create               ; make the dict entry
            dw lit, docon           ; set the codeword
            dw latest, fetch, tocfa
            dw store
            dw comma                ; compile the constant
            dw exit

; dictionary
            ; ( a u -- 0 0  |  xt 1  |  xt -1 )
            defcode(find, 0, find)
            set a, [z]
            set b, [1+z]
            jsr find_
            set [1+z], j
            set [z], i
            next

            ; find word in dictionary. word len in a, ptr in b.
            ; returns xt in j, i = 1, -1, 0 for found, immediate, and not found
            ; does NOT clobber a or b
find_:      set c, [var_latest]     ; start with most recent word
find_.1:    ife c, 0                ; end of dict?
            set pc, find_.fail
            set j, [1+c]            ; load flags/len
            ifb j, f_hidden         ; ignore if hidden
            set pc, find_.2
            and j, f_lenmask        ; mask off flags
            ifn j, a                ; compare length
            set pc, find_.2

            set i, b                ; i points into input word
            set j, c                ; j points into dict word
            add j, 2
            set push, i             ; stack gets limit of input word
            add peek, a
find_.3:    ife i, peek             ; check for full match
            set pc, find_.succ
            ifn [i], [j]
            set pc, find_.4
            add i, 1
            add j, 1
            set pc, find_.3

find_.4:    set i, pop              ; pop limit, dest doesn't matter
find_.2:    set c, [c]              ; `next' word in dict
            set pc, find_.1

find_.succ: set i, pop              ; pop limit, dest doesn't matter
            ; j already points to the xt...
            set i, 1                ; found
            ifb [1+c], f_immed      ; immediate?
            set i, -1               ; if so, mark it
            set pc, pop

find_.fail: set i, 0
            set j, 0
            set pc, pop


            ; ( addr -- xt )  addr points to start of dict entry
            defcode(>cfa, 0, tocfa)
            add [z], 1              ; advance to len field
            set a, [z]              ; load len field addr
            set a, [a]              ; load actual len field
            and a, f_lenmask        ; mask off the flags
            add [z], 1              ; advance to start of name
            add [z], a              ; advance to code ptr
            next

; the outer interpreter
            defvar(succ, succ, 0)

            ; ( -- ? )
            defword(interpret, 0, interpret)
            dw state, fetch         ; if we're currently in compile mode...
            dw zbranch, 2
            dw rbrac                ; resume compiling, until finished
            dw parseword            ; otherwise (or and then) interpret...
            dw dup, zbranch, 8      ; done?
            dw interpret_           ; call the primitive
            dw succ, fetch          ; check for error
            dw zbranch, 7           ; error!
            dw branch, -10          ; keep parsing...
            dw twodrop, lit, 0xffff ; push true
            dw exit
            dw lit, 0x0             ; push false
            dw exit

            ; this can't return anything, since execution will cause us to
            ; eventually `next' our way back into forth code. we could make
            ; it work by fiddling around with the forth ip, but it doesn't seem
            ; worth it... we use a var to communicate errors...
            ; ( a u -- )
interpret_: dw interp_
interp_:    set a, [z]              ; load length
            set b, [1+z]            ; load ptr
            add z, 2
            set [var_succ], 0xffff
            jsr find_               ; dictionary search, results in i, j
            ife i, 0
            set pc, interp_.1       ; not in dict...
            set x, j                ; found. update the codeword pointer
            set pc, [x]             ; and execute it...
interp_.1:  jsr number_
            ife a, 0
            set pc, interp_.2
            set [var_succ], 0x0     ; not a number. bail.
            set pc, interp_.3
interp_.2:  sub z, 1                ; got a number. push it.
            set [z], i
interp_.3:  next


; boot is basically a simplified quit, without the prompts...
; we just use this to achieve a quiet bootup while executing forth.ft.
            defword(boot, 0, boot)
            dw refill, drop         ; refill input buffer
            dw interpret, zequ      ; run
            dw zbranch, 2           ; check result
            dw err
            dw branch, -8           ; again

; just a minimal indication that an error occurred during boostrap
err:        dw err_
err_:       set j, 0x45
            jsr emit_
            next

; we indirect the actual boot through a variable, so that we can reset
; the boot word before saving the final image.
            defvar(boot-word, bootword, boot)
; define h down here, so it's clear where it's coming from...
            defvar(h, h, h_init)
; define latest last, so that it can start out pointing to itself.
            defvar(latest, latest, name_latest)
; label for initial value for h
h_init:     ; nothing here!

; the fun continues in forth.ft...
